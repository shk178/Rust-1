- .len() gives the size of the string in bytes.
```rust
use std::mem::size_of;
fn main() {
    println!("{}", size_of::<char>()); // 4
    println!("{}", "a".len()); // 1
    println!("{}", "ß".len()); // 2
    println!("{}", "ßßß".len()); // 6
    println!("{}", "国".len()); // 3
    println!("{}", "𓅱".len()); // 4
}
```
- .chars().count() is about the size in characters.
```rust
fn main() {
    let slice = "Hello!";
    println!("Slice is {} bytes and also {} characters.", slice.len(), slice.chars().count()); // 6, 6
    let slice2 = "안녕!";
    println!("Slice2 is {} bytes but only {} characters.", slice2.len(), slice2.chars().count()); // 7, 3
}
```
---
# UTF-8에서 "안"의 크기
- "안"은 유니코드 코드포인트 U+C548 입니다.
- UTF-8에서는 U+0800 ~ U+FFFF 범위의 문자는 3바이트로 인코딩됩니다.
- 따라서 "안" → [EC, 95, 88] (16진수) → 총 3바이트
- 일부 인코딩(예: EUC-KR, UTF-16)에서는 한글이 2바이트로 표현됩니다.
- 하지만 Rust는 UTF-8을 기본으로 하므로 한글은 3바이트가 됩니다.
# u8 값과 UTF-8의 관계
- Rust에서 String은 UTF-8 인코딩된 바이트 시퀀스입니다.
- 하지만 모든 u8 값이 독립적인 "유효한 Unicode 문자"로 직접 대응하는 건 아닙니다.
- UTF-8은 가변 길이 인코딩이라서, 어떤 문자는 1바이트, 어떤 문자는 2~4바이트를 차지합니다.
- ASCII 영역(U+0000 ~ U+007F)은 1바이트로 표현되며, 이 경우 u8 값과 코드포인트가 동일합니다.
- 예: b'A' == 65 == 'A' (U+0041)
- 하지만 한글 "안"(U+C548)은 UTF-8에서 [0xEC, 0x95, 0x88] 세 개의 u8이 합쳐져서 하나의 문자로 해석됩니다.
- 모든 u8 값(0~255)은 UTF-8에서 "어딘가에 등장할 수 있는 바이트"이긴 하지만, 그 자체로 문자 하나를 보장하지는 않습니다.
- 0x00~0x7F 범위의 u8 값은 문자와 직접 1:1 대응하지만, 0x80 이상은 다른 바이트와 조합되어야 문자 하나가 된다는 말이 맞습니다.
# "유효한 바이트" vs "유효한 문자"
- UTF-8에서 모든 u8 조합이 문자로 해석될 수 있는 건 아닙니다.
- 예를 들어 [0xC0] 같은 값은 단독으로는 잘못된 UTF-8 시퀀스입니다. (C0으로 시작하면 최소 2바이트 이상 와야 하는데 뒤가 없음)
- 따라서 String은 항상 올바른 UTF-8만 저장되도록 보장합니다.
- 반대로 Vec<u8>는 그냥 임의의 바이트 배열이므로 잘못된 UTF-8 시퀀스가 들어올 수도 있어요.
```rust
fn main() {
    let s = "안"; // 유니코드 코드포인트 U+C548, UTF-8 인코딩 = 0xEC 0x95 0x88 (3바이트)
    // 문자열을 바이트 배열로 변환
    let bytes = s.as_bytes(); // as_bytes() → [236, 149, 136] (10진수)
    println!("{:?}", bytes);
    // [236, 149, 136]
    // 바이트 배열을 다시 UTF-8 문자열로 변환
    let from_bytes = std::str::from_utf8(bytes).unwrap(); // from_utf8() → 다시 "안"으로 복원
    println!("{}", from_bytes);
    // "안"
    // 각각의 u8 값을 (바이트를) 16진수로 출력
    for b in bytes {
        println!("0x{:X}", b);
    }
    // 0xEC
    // 0x95
    // 0x88
}
```
```rust
fn main() {
    let s = "안녕!";
    let bytes = s.as_bytes();
    println!("{:?}", bytes);
    // [236, 149, 136, 235, 133, 149, 33]
    let from_bytes = std::str::from_utf8(bytes).unwrap();
    println!("{}", from_bytes);
    // 안녕!
    for b in bytes {
        println!("0x{:X}", b);
    }
    // 0xEC
    // 0x95
    // 0x88
    // 0xEB
    // 0x85
    // 0x95
    // 0x21
}
```
- "녕" (U+B155)이 어떻게 UTF-8 바이트 [0xEB, 0x85, 0x95]로 변환되는지 계산 과정
```
1단계: Unicode 코드 포인트 확인
- '녕' = U+B155 (16진수 0xB155)
- = 45,397 (10진수)
- = 1011 0001 0101 0101 (2진수)
2단계: UTF-8 인코딩 규칙 확인
- Unicode 범위에 따라 UTF-8 바이트 수가 결정됩니다:
- U+0000 ~ U+007F -> 0xxxxxxx (1바이트)
- U+0080 ~ U+07FF -> 110xxxxx 10xxxxxx (2바이트)
- U+0800 ~ U+FFFF -> 1110xxxx 10xxxxxx 10xxxxxx (3바이트)
- U+10000 ~ U+10FFFF -> 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (4바이트)
- U+B155는 U+0800 ~ U+FFFF 범위라서 3바이트 패턴 사용
3단계: 2진수를 UTF-8 패턴에 맞추기
- 원본 2진수 (16비트): U+B155 = 1011 0001 0101 0101
- UTF-8 3바이트 패턴: 1110xxxx 10xxxxxx 10xxxxxx
- 비트 채우기 (오른쪽부터 역순으로)
- 원본: (1011) (0001 01)(01 0101)
- 패턴에 맞추기: 1110xxxx → 1110 1011 (상위 4비트) = 0xEB
- 10xxxxxx → 1000 0101 (중간 6비트) = 0x85
- 10xxxxxx → 1001 0101 (하위 6비트) = 0x95
```
- '녕'과 "녕"
- 저장 방식: char는 Unicode, str은 UTF-8
- 메모리 크기: char는 4바이트, str의 '녕'은 3바이트
```rust
fn main() {
    // char: 메모리에 Unicode 코드포인트로 저장 (4바이트)
    let ch: char = '녕';  // 내부: 0x0000B155 (4바이트)
    // &str: 메모리에 UTF-8 바이트로 저장
    let s: &str = "녕";   // 내부: [0xEB, 0x85, 0x95] (3바이트)
    // 하지만 출력/변환하면 결과는 동일
    println!("{}", ch);  // 녕
    println!("{}", s);   // 녕
}
```
- '녕'과 "녕": UTF-8 인코딩 과정 (결과 동일)
- '녕' → U+B155 → UTF-8 변환 → [0xEB, 0x85, 0x95]
- "녕" → 이미 UTF-8 → [0xEB, 0x85, 0x95]
```rust
fn main() {
    // char: 단일 문자, 빠른 접근과 처리가 중요
    let ch: char = '녕';  // 4바이트 (고정 크기)
    // 장점: O(1) 시간에 모든 Unicode 문자 표현 가능
    // 장점: 간단한 메모리 레이아웃
    // &str: 문자열, 저장 효율이 중요
    let s: &str = "안녕하세요"; // 가변 크기 UTF-8
    // 장점: 메모리 효율적
    // 장점: 네트워크 전송, 파일 저장에 유리
    // 단점: 인덱싱이 복잡 (바이트 단위 vs 문자 단위)
}
```
- "녕"이 UTF-8로 변환하는 이유:
- 메모리 효율: 4바이트 대신 3바이트 (25% 절약)
- 영어는 더 효율적: 'A'는 4바이트 대신 1바이트 (75% 절약)
- 웹 표준: 인터넷의 대부분이 UTF-8 사용
- ASCII 호환: 기존 시스템과 호환
- char는 4바이트 고정:
- 단일 문자 처리의 단순성
- 모든 Unicode 문자를 동일한 크기로 처리
- 배열 인덱싱 등이 간단해짐
# 참고
- Unicode의 설계 철학: "전 세계 모든 문자에 고유한 번호를 부여하자"
- 목적: 문자의 식별 체계 (Identification System), "이 문자는 45,397번이다" 같은 고유 ID 부여
- 저장 방식과는 무관한 추상적 개념
- 설계 원칙
```
1. 보편성 (Universality)
- 전 세계 모든 문자 포함
- 고대 문자, 이모지까지 모두
2. 유일성 (Uniqueness)  
- 하나의 문자 = 하나의 번호
- 'A'는 항상 U+0041
3. 효율성보다 완전성
- 메모리 효율은 고려 안 함
- 모든 문자를 표현하는 게 우선
4. 확장성
- 현재: 0 ~ 10FFFF (약 110만 개 공간)
- 실제 사용: 약 15만 개
```
- Unicode 예시
```rust
fn main() {
    // Unicode는 그냥 "번호표"
    println!("A = U+{:04X}", 'A' as u32);        // U+0041
    println!("가 = U+{:04X}", '가' as u32);      // U+AC00
    println!("😀 = U+{:04X}", '😀' as u32);     // U+1F600
    println!("𒀀 = U+{:04X}", '𒀀' as u32);     // U+12000 (설형문자)
    // 모든 문자는 고유한 숫자를 가짐
    // 어떻게 저장할지는 Unicode가 신경 안 씀!
}
```
- UTF-8의 설계 철학: "Unicode를 효율적으로 저장/전송하자"
- 목적: Unicode의 구현 방식 (Implementation/Encoding), 메모리와 대역폭 절약, 기존 시스템(ASCII)과의 호환
- 설계 원칙
```
1. 가변 길이 (Variable Length)
- 자주 쓰는 문자: 짧게 (1바이트)
- 덜 쓰는 문자: 길게 (2-4바이트)
2. ASCII 호환 (Backward Compatibility)
- 0-127은 ASCII와 완전 동일
- 기존 시스템과 호환
3. 자기 동기화 (Self-Synchronization)
- 중간부터 읽어도 문자 경계 찾기 가능
- 오류에 강함
4. 효율성
- 영어 중심 텍스트에서 최대 효율
- 웹/네트워크 전송에 최적화
```
- UTF-8 인코딩 규칙
```
Unicode 범위       UTF-8 바이트 수    사용 예시
-------------------------------------------------
U+0000 ~ U+007F    1바이트           영어, 숫자
U+0080 ~ U+07FF    2바이트           그리스어, 히브리어
U+0800 ~ U+FFFF    3바이트           한글, 한자, 일본어
U+10000 ~ U+10FFFF 4바이트           이모지, 고대 문자
```
- Unicode를 구현하는 방법은 여러 가지:
- UTF-32 (고정 길이)
```
// 모든 문자 = 4바이트
"A"    → [0x00, 0x00, 0x00, 0x41] (4바이트)
"녕"   → [0x00, 0x00, 0xB1, 0x55] (4바이트)
"😀"   → [0x00, 0x01, 0xF6, 0x00] (4바이트)
- 장점: 인덱싱 간단 (모든 문자 같은 크기)
- 단점: 메모리 낭비 심함
- 철학: "단순함이 최고다"
```
- UTF-16 (중간 길이)
```
// 대부분 2바이트, 일부 4바이트
"A"    → [0x00, 0x41] (2바이트)
"녕"   → [0xB1, 0x55] (2바이트)
"😀"   → [0xD8, 0x3D, 0xDE, 0x00] (4바이트)
장점: 한글/한자에 효율적
단점: ASCII 호환 안 됨
철학: "CJK(중국/일본/한국) 문자 우선"
사용: Windows, Java 내부
```
- UTF-8 (가변 길이)
```
// 1-4바이트
"A"    → [0x41] (1바이트)
"녕"   → [0xEB, 0x85, 0x95] (3바이트)
"😀"   → [0xF0, 0x9F, 0x98, 0x80] (4바이트)
장점: ASCII 호환, 영어에 효율적
단점: 한글은 3바이트 (비효율)
철학: "웹/인터넷 최적화"
사용: 웹의 98%, Linux, macOS
```
---